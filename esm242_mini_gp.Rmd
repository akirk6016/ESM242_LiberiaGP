---
title: "esm242_mini_gp"
author: "Abigail Kirk"
date: "2024-11-19"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
library(nloptr)
library(knitr)
```


This problem involves a fish stock that evolves according to $X_{t+1}=X_t+F(X_t)-Y_t$, where the growth function is given by $F(X_t)=rX_t(1-X_t/K)$.  The profits from the fishery in each period are $pY_t-(c/2)*Y_t^2/X_t$ and the catch is proportional to the stock: $Y_t=\alpha X_t$. The objective is to maximize the present value of net benefits (PVNB) from time 0 to time 19 by selecting the catchability coefficient $\alpha$: 

AK notes: Should we / do we need to write another loop to pull individual benefits for SSF / DWF? Would be curious to see how in this case the benefits are currently spread out. But this might be a more interesting question for when we have alpha in their, along with the weightings. 

Agenda for Nate:

- Gut check biological model 
- review mathematics of profit function
- Review current R code
- discuss weighting + how to incorporate into the model
- Assumptions needed?
 
- price is the true reflection of how the people value the fish, but some people eat their fish. would need to make something up
- keep market price, but then keep it as movable parameter + p of consumption, which will never be estimated
 - to ballpark it when uncertain, can we calibrate it to reflect what we see in the real world (i.e. what we see in the current data) 
- estimating costs: we can ignore cost and say that fishers will fish down to some level every single time
- main reason we want convexity in the model, but we have that in the biological model
- hard to estimate weighting parameter and make decisions off of it. 
- what does the shape of our alpha v. beta graph look like?
- if beta = one, then we need to add cost data for SSF to keep convexity 
- what is the cost relative to how much benefit I get. or use cost from some other fishery, 
- assume some linear cost, which c fits the data the best? use captain data, just do simple algebra to find. 
- here can say that this highlights the importance of NaFAA collecting data. 
- Cost Paramater that we can estimate later. 
- we are choosing one alpha across all time periods 
- can use optum 
DD Notes: Adding in another version that optimizes effort, and including a table function to visualize

* model description:
- effort is a choice matrix between two fishers and 10 periods
- the state is the fish stock. In this case we are using a simple schaefer model for stock that both fishers are fishing from
- the yield is the product of the stock and the effort for each fisher.
  * but does this capture that the catch of one impacts the catch of the other?
- Simple individual prfit functions are used, optimization is done on the sum of the two functions. 

```{r}
local_opts<-list("algorithm"="NLOPT_LN_COBYLA",xtol_rel=1e-15)
options=list("algorithm"="NLOPT_LN_AUGLAG",xtol_rel=1e-15,maxeval=160000,"local_opts"=local_opts)

harvest_dwf <- function(choice, int_state, alpha, p, c_d, q, r, K, discount, period) {
  
  benefits=vector(mode="numeric", length=0)
  # choice=vector(mode="numeric",length=0)
  state=vector(mode="numeric",length=0)
  
  state[1]=int_state
  benefits[1]=(p*(1-alpha)*choice[1])-(c_d*((choice[1]/(q*state[1]))^2))
  
  rho=1/(1+discount)
  
  for(i in 2:period){
    
    state[i]=state[i-1]+(state[i-1]*r*(1-(state[i-1]/K)))-choice[i-1]
    
    benefits[i]=(p*((1-alpha)*choice[i]))-(c_d*((choice[i]/(q*state[i]))^2))
  }
  
  t=seq(from=0,to=period-1)
  
  pv=rho^t*benefits
  npv=sum(pv)
  
  return(-npv)
}

constraint_dwf <- function(choice, int_state, alpha, p, c_d, q, r, K, discount, period) {
  
  state=vector(mode="numeric", length=0)
  const=vector(mode="numeric", length=0)
  
  state[1]=int_state
  const[1]=choice[1]-state[1]
  
  for(i in 2:period) {
    
    state[i]=state[i-1]+(state[i-1]*r*(1-(state[i-1]/K)))-choice[i-1]
    const[i]=choice[i]-state[i]
  }
  
  return(const)
}

period=50

H_d_out = nloptr(
  x0 = rep(500000, period),
  eval_f = harvest_dwf,
  lb = rep(0, period),
  opts = options,
  eval_g_ineq = constraint_dwf,
  int_state = 60000000,
  alpha = 0.8,
  p = 1.3,
  c_d = 0.63,
  q = 0.01,
  r = 0.45,
  K = 100000000,
  discount = 0.05,
  period = 50
)

# Huzzah! The harvest function works as well as the constraint, which puts an upper bound essentially on it 

benefits_fct <- function(choice, Hd_fct, constraintd_fct, discount, period, beta, Pi_s){
  
  benefits=vector(mode="numeric",length=0)
  
  rho=1/(1+discount)
  
  for(i in 1:period) {
    benefits[i]=beta*Pi_s + (1-beta)*choice*(nloptr(x0 = rep(500000, period),eval_f = Hd_fct,lb = rep(0, period),opts = options,eval_g_ineq = constraintd_fct,int_state = 60000000,alpha = choice,p = 1.3,c_d = 0.63,q = 0.01,r = 0.45,K = 100000000,discount = 0.05,period = 50)$objective[i])
  }
  
  t=seq(from=0, to=period-1)
  pv=rho^t*benefits
  npv=sum(pv)
  
  return(-npv)
}

benefits_out=nloptr(x0=0.2,
                    eval_f = benefits_fct,
                    opts = options,
                    lb = 0,
                    ub = 1,
                    Hd_fct = harvest_dwf,
                    constraintd_fct = constraint_dwf,
                    discount = 0.05,
                    period = 50,
                    beta = 0.5,
                    Pi_s = 100000
                    )
benefits_out$solution
-benefits_out$objective
```




